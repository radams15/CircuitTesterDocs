{-
Function that solves the circuit using
linear algebra and matrices.
-}
FUNCTION solve()
	equations = get_equations()
	unknown_currents = get_unknown_currents()
	unknown_voltages = MAP({x => NEW UnknownVoltage(x)}, nodes)
	
	unknowns = unknown_currents + unknown_voltages
	
	-- Make two matrices, one which is wide, and the other that is only 1 wide.
	a = Matrix.Zeroes(Float, equations.length(), get_num_vars())
	z = Matrix.Zeroes(Float, equations.length(), 1)
	
	FOR i IN (0 .. equations.length()) DO
		-- Stamp every equation, passing in the lambda to find the index of each
		-- term of the equation in class attribute unknowns.
		equations[i].stamp(i, a, z, {x => get_index_by_equals(unknowns, x})
	END
	
	TRY
		-- Hopefully the equation is solved
		x = a.solve(z)
	CATCH EXCEPTION
		-- If there is an error, make an empty output matrix
		-- to stop the whole program from crashing.
		x = Matrix.Zeroes(Float, equations.length(), 1)
	END
	
	voltage_map = {}
	
	FOR v IN unknown_voltages DO
		-- Get the right side of the equation for the voltage at
		-- point voltage node.
		equation_right = x[get_index_by_equals(unknowns, v), 0]
		voltage_map[v.node] = equation_right
	END
	
	FOR c IN unknown_currents DO
		-- Set the new current for each element.
		c.element.current_solution = x[get_index_by_equals(unknowns, c), 0]
	END
	
	-- Return a new solution class.
	RETURN NEW Solution(voltage_map, map({x => x.element}, unknown_currents}))
END
